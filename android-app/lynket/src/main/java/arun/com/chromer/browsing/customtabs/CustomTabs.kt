/*
 * Phase 7: Converted from Java to Kotlin
 *
 *  Lynket
 *
 *  Copyright (C) 2022 Arunkumar
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package arun.com.chromer.browsing.customtabs

import android.annotation.TargetApi
import android.app.Activity
import android.app.PendingIntent
import android.app.PendingIntent.FLAG_IMMUTABLE
import android.app.PendingIntent.FLAG_UPDATE_CURRENT
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.Color.WHITE
import android.graphics.drawable.Drawable
import android.net.Uri
import android.os.Build
import android.widget.Toast
import androidx.annotation.ColorInt
import androidx.browser.customtabs.CustomTabsIntent
import androidx.browser.customtabs.CustomTabsSession
import androidx.core.graphics.ColorUtils
import com.mikepenz.community_material_typeface_library.CommunityMaterial
import com.mikepenz.iconics.IconicsDrawable
import arun.com.chromer.R
import arun.com.chromer.browsing.customtabs.bottombar.BottomBarManager.createBottomBarRemoteViews
import arun.com.chromer.browsing.customtabs.bottombar.BottomBarManager.getClickableIDs
import arun.com.chromer.browsing.customtabs.bottombar.BottomBarManager.getOnClickPendingIntent
import arun.com.chromer.browsing.customtabs.callbacks.CopyToClipboardReceiver
import arun.com.chromer.browsing.customtabs.callbacks.FavShareBroadcastReceiver
import arun.com.chromer.browsing.customtabs.callbacks.MinimizeBroadcastReceiver
import arun.com.chromer.browsing.customtabs.callbacks.OpenInChromeReceiver
import arun.com.chromer.browsing.customtabs.callbacks.SecondaryBrowserReceiver
import arun.com.chromer.browsing.customtabs.callbacks.ShareBroadcastReceiver
import arun.com.chromer.browsing.openwith.OpenIntentWithActivity
import arun.com.chromer.browsing.optionspopup.ChromerOptionsActivity
import arun.com.chromer.browsing.webview.WebViewActivity
import arun.com.chromer.bubbles.webheads.WebHeadService
import arun.com.chromer.settings.Preferences
import arun.com.chromer.settings.Preferences.ANIMATION_MEDIUM
import arun.com.chromer.settings.Preferences.ANIMATION_SHORT
import arun.com.chromer.settings.Preferences.PREFERRED_ACTION_BROWSER
import arun.com.chromer.settings.Preferences.PREFERRED_ACTION_FAV_SHARE
import arun.com.chromer.settings.Preferences.PREFERRED_ACTION_GEN_SHARE
import arun.com.chromer.shared.Constants.EXTRA_KEY_ORIGINAL_URL
import arun.com.chromer.shared.Constants.NO_COLOR
import arun.com.chromer.util.Utils
import timber.log.Timber
import java.util.Random
import javax.inject.Inject

/**
 * A helper class that builds up the view intent according to user Preferences.get(activity) and
 * launches custom tab.
 */
class CustomTabs @Inject constructor(
    private var activity: Activity?
) {
    /**
     * The url for which the custom tab should be launched;
     */
    private var url: String? = null

    /**
     * The builder used to customize the custom tab intent
     */
    private var builder: CustomTabsIntent.Builder? = null

    /**
     * Client provided custom tab session
     */
    private var customTabsSession: CustomTabsSession? = null

    /**
     * Toolbar color that overrides the default toolbar color generated by this helper.
     */
    @ColorInt
    private var toolbarColor = NO_COLOR
    private var noAnimation = false

    init {
        noAnimation = false
    }

    /**
     * Opens the URL on a Custom Tab if possible. Otherwise fallsback to opening it on a WebView.
     */
    private fun openCustomTab() {
        val act = activity ?: return
        val packageName = getCustomTabPackage(act)
        val customTabsIntent = builder!!.build()
        val uri = Uri.parse(url)
        if (packageName != null) {
            customTabsIntent.intent.setPackage(packageName)
            val keepAliveIntent = Intent()
            keepAliveIntent.setClassName(act.packageName, KeepAliveService::class.java.canonicalName!!)
            customTabsIntent.intent.putExtra(EXTRA_CUSTOM_TABS_KEEP_ALIVE, keepAliveIntent)
            try {
                customTabsIntent.launchUrl(act, uri)
                Timber.d("Launched url: %s", uri.toString())
            } catch (e: Exception) {
                CUSTOM_TABS_FALLBACK.openUri(act, uri)
                Timber.e("Called fallback even though a package was found, weird Exception : %s", e.toString())
            }
        } else {
            Timber.e("Called fallback since no package found!")
            CUSTOM_TABS_FALLBACK.openUri(act, uri)
        }
    }

    fun withSession(session: CustomTabsSession?): CustomTabs {
        if (session != null) {
            customTabsSession = session
        }
        return this
    }

    /**
     * Exposed method to set the url for which this CCT should be launched
     *
     * @param url Url of the web site
     */
    fun forUrl(url: String): CustomTabs {
        this.url = url.trim()
        return this
    }

    fun toolbarColor(@ColorInt overrideColor: Int): CustomTabs {
        toolbarColor = ColorUtils.setAlphaComponent(overrideColor, 0xFF)
        return this
    }

    /**
     * Facade method that does all the heavy work of building up the builder based on user Preferences.get(activity)
     *
     * @return Instance of this class
     */
    private fun prepare(): CustomTabs {
        builder = CustomTabsIntent.Builder(getSession())
        // set defaults
        builder!!.setShowTitle(true)
        builder!!.enableUrlBarHiding()
        builder!!.addDefaultShareMenuItem()
        builder!!.setToolbarColor(toolbarColor).setSecondaryToolbarColor(toolbarColor)

        prepareAnimations()
        prepareActionButton()
        prepareMenuItems()
        prepareBottomBar()
        return this
    }

    /**
     * Builds custom tab intent from the builder we created so far and launches the custom tab.
     */
    fun launch() {
        prepare()
        assertBuilderInitialized()
        openCustomTab()

        // Dispose reference
        activity = null
        customTabsSession = null
    }

    /**
     * Tries to find available sessions for the url to launch in.
     *
     * @return Instance of this class
     */
    private fun getSession(): CustomTabsSession? {
        if (customTabsSession != null) {
            return customTabsSession
        }
        if (WebHeadService.getTabSession() != null) {
            Timber.d("Using webhead session")
            return WebHeadService.getTabSession()
        }
        return null
    }

    /**
     * Used to set the correct custom tab opening/closing animations. Will re use last used animations
     * if the preference did not change from before.
     */
    private fun prepareAnimations() {
        assertBuilderInitialized()
        val act = activity ?: return
        if (Preferences.get(act).isAnimationEnabled() && !noAnimation) {
            val type = Preferences.get(act).animationType()
            val speed = Preferences.get(act).animationSpeed()
            var start = intArrayOf()
            var exit = intArrayOf()
            when (speed) {
                ANIMATION_MEDIUM -> {
                    when (type) {
                        1 -> {
                            start = intArrayOf(R.anim.slide_in_right_medium, R.anim.slide_out_left_medium)
                            exit = intArrayOf(R.anim.slide_in_left_medium, R.anim.slide_out_right_medium)
                        }
                        2 -> {
                            start = intArrayOf(R.anim.slide_up_right_medium, R.anim.slide_down_left_medium)
                            exit = intArrayOf(R.anim.slide_up_left_medium, R.anim.slide_down_right_medium)
                        }
                    }
                }
                ANIMATION_SHORT -> {
                    when (type) {
                        1 -> {
                            start = intArrayOf(R.anim.slide_in_right, R.anim.slide_out_left)
                            exit = intArrayOf(R.anim.slide_in_left, R.anim.slide_out_right)
                        }
                        2 -> {
                            start = intArrayOf(R.anim.slide_up_right, R.anim.slide_down_left)
                            exit = intArrayOf(R.anim.slide_up_left, R.anim.slide_down_right)
                        }
                    }
                }
            }
            // set it to builder
            builder!!
                .setStartAnimations(act, start[0], start[1])
                .setExitAnimations(act, exit[0], exit[1])
            act.overridePendingTransition(start[0], start[1])
        }
    }

    /**
     * Used to set the action button based on user Preferences.get(activity). Usually secondary browser or favorite share app.
     */
    private fun prepareActionButton() {
        assertBuilderInitialized()
        val act = activity ?: return
        when (Preferences.get(act).preferredAction()) {
            PREFERRED_ACTION_BROWSER -> {
                val pakage = Preferences.get(act).secondaryBrowserPackage()
                if (Utils.isPackageInstalled(act, pakage)) {
                    val icon = getAppIconBitmap(pakage)
                    val intent = Intent(act, SecondaryBrowserReceiver::class.java)
                    val openBrowserPending = PendingIntent.getBroadcast(act, 0, intent, getPendingIntentFlags())
                    builder!!.setActionButton(icon, act.getString(R.string.choose_secondary_browser), openBrowserPending)
                }
            }
            PREFERRED_ACTION_FAV_SHARE -> {
                val pakage = Preferences.get(act).favSharePackage()
                if (Utils.isPackageInstalled(act, pakage)) {
                    val icon = getAppIconBitmap(pakage)
                    val intent = Intent(act, FavShareBroadcastReceiver::class.java)
                    val favSharePending = PendingIntent.getBroadcast(act, 0, intent, getPendingIntentFlags())
                    builder!!.setActionButton(icon, act.getString(R.string.fav_share_app), favSharePending)
                }
            }
            PREFERRED_ACTION_GEN_SHARE -> {
                val shareIcon = IconicsDrawable(act)
                    .icon(CommunityMaterial.Icon.cmd_share_variant)
                    .color(WHITE)
                    .sizeDp(24).toBitmap()
                val intent = Intent(act, ShareBroadcastReceiver::class.java)
                val sharePending = PendingIntent.getBroadcast(act, 0, intent, getPendingIntentFlags())
                builder!!.setActionButton(shareIcon, act.getString(R.string.share_via), sharePending, true)
            }
        }
    }

    /**
     * Prepares all the menu items and adds to builder
     */
    private fun prepareMenuItems() {
        assertBuilderInitialized()
        preparePreferredAction()
        prepareMinimize()
        prepareCopyLink()
        // prepareAddToHomeScreen();
        // prepareOpenWith();
        prepareOpenInChrome()
        prepareChromerOptions()
    }

    private fun prepareChromerOptions() {
        val act = activity ?: return
        val moreMenuActivity = Intent(act, ChromerOptionsActivity::class.java)
        moreMenuActivity.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        moreMenuActivity.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK)
        moreMenuActivity.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT)
        moreMenuActivity.putExtra(EXTRA_KEY_ORIGINAL_URL, url)
        val moreMenuPending = PendingIntent.getActivity(
            act,
            0,
            moreMenuActivity,
            getPendingIntentFlags()
        )
        builder!!.addMenuItem(act.getString(R.string.chromer_options), moreMenuPending)
    }

    /**
     * Adds a menu item tapping which will minimize the current custom tab back to overview. This requires
     * merge tabs and apps and
     */
    private fun prepareMinimize() {
        val act = activity ?: return
        if (!Preferences.get(act).bottomBar() && Utils.ANDROID_LOLLIPOP) {
            val minimizeIntent = Intent(act, MinimizeBroadcastReceiver::class.java)
            minimizeIntent.putExtra(EXTRA_KEY_ORIGINAL_URL, url)
            val pendingMin = PendingIntent.getBroadcast(act, Random().nextInt(), minimizeIntent, getPendingIntentFlags())
            builder!!.addMenuItem(act.getString(R.string.minimize), pendingMin)
        }
    }

    /**
     * Opposite of what [prepareActionButton] does. Fills a menu item with either secondary
     * browser or favorite share app.
     */
    private fun preparePreferredAction() {
        assertBuilderInitialized()
        val act = activity ?: return
        when (Preferences.get(act).preferredAction()) {
            PREFERRED_ACTION_BROWSER -> {
                val pkg = Preferences.get(act).favSharePackage()
                if (Utils.isPackageInstalled(act, pkg)) {
                    val app = Utils.getAppNameWithPackage(act, pkg)
                    val label = String.format(act.getString(R.string.share_with), app)
                    val shareIntent = Intent(act, FavShareBroadcastReceiver::class.java)
                    val pendingShareIntent = PendingIntent.getBroadcast(act, 0, shareIntent, getPendingIntentFlags())
                    builder!!.addMenuItem(label, pendingShareIntent)
                }
            }
            PREFERRED_ACTION_FAV_SHARE -> {
                val pkg = Preferences.get(act).secondaryBrowserPackage()
                if (Utils.isPackageInstalled(act, pkg)) {
                    if (!pkg.equals(STABLE_PACKAGE, ignoreCase = true)) {
                        val app = Utils.getAppNameWithPackage(act, pkg)
                        val label = String.format(act.getString(R.string.open_in_browser), app)
                        val browseIntent = Intent(act, SecondaryBrowserReceiver::class.java)
                        val pendingBrowseIntent = PendingIntent.getBroadcast(act, 0, browseIntent, getPendingIntentFlags())
                        builder!!.addMenuItem(label, pendingBrowseIntent)
                    } else {
                        Timber.d("Excluded secondary browser menu as it was Chrome")
                    }
                }
            }
        }
    }

    private fun prepareCopyLink() {
        val act = activity ?: return
        val clipboardIntent = Intent(act, CopyToClipboardReceiver::class.java)
        clipboardIntent.putExtra(EXTRA_KEY_ORIGINAL_URL, url)
        val serviceIntentPending = PendingIntent.getBroadcast(act, 0, clipboardIntent, getPendingIntentFlags())
        builder!!.addMenuItem(act.getString(R.string.copy_link), serviceIntentPending)
    }

    /**
     * Adds an open in chrome option
     */
    private fun prepareOpenInChrome() {
        val act = activity ?: return
        val customTabPkg = Preferences.get(act).customTabPackage()
        if (Utils.isPackageInstalled(act, customTabPkg)) {
            if (customTabPkg.equals(BETA_PACKAGE, ignoreCase = true) ||
                customTabPkg.equals(DEV_PACKAGE, ignoreCase = true) ||
                customTabPkg.equals(STABLE_PACKAGE, ignoreCase = true)
            ) {
                val chromeReceiver = Intent(act, OpenInChromeReceiver::class.java)
                val openChromePending = PendingIntent.getBroadcast(act, 0, chromeReceiver, getPendingIntentFlags())

                val app = Utils.getAppNameWithPackage(act, customTabPkg)
                val label = String.format(act.getString(R.string.open_in_browser), app)
                builder!!.addMenuItem(label, openChromePending)
            }
        }
    }

    private fun prepareOpenWith() {
        val act = activity ?: return
        val openWithActivity = Intent(act, OpenIntentWithActivity::class.java)
        openWithActivity.putExtra(EXTRA_KEY_ORIGINAL_URL, url)
        val openWithActivityPending = PendingIntent.getActivity(act, 0, openWithActivity, getPendingIntentFlags())
        builder!!.addMenuItem(act.getString(R.string.open_with), openWithActivityPending)
    }

    /**
     * Add all bottom bar actions
     */
    private fun prepareBottomBar() {
        val act = activity ?: return
        if (!Preferences.get(act).bottomBar()) {
            return
        }
        builder!!.setSecondaryToolbarViews(
            createBottomBarRemoteViews(act, toolbarColor),
            getClickableIDs(),
            getOnClickPendingIntent(act, url!!)
        )
    }

    /**
     * Method to check if the builder was initialized. Will fail fast if not.
     */
    private fun assertBuilderInitialized() {
        if (builder == null) {
            throw IllegalStateException("Intent builder null. Are you sure you called prepare()")
        }
    }

    /**
     * Returns the bitmap of the app icon. It is assumed, the package is installed.
     *
     * @return App icon bitmap
     */
    private fun getAppIconBitmap(packageName: String): Bitmap? {
        val act = activity ?: return null
        try {
            val drawable: Drawable = act.packageManager.getApplicationIcon(packageName)
            val appIcon = Utils.drawableToBitmap(drawable)
            return Utils.scale(appIcon, Utils.dpToPx(24.0), true)
        } catch (e: Exception) {
            Timber.e("App icon fetching for %s failed", packageName)
        }
        return null
    }

    private fun chromeVariantVersion(): Int {
        val act = activity ?: return -1
        val customTabPackage = Preferences.get(act).customTabPackage()
        if (Utils.isPackageInstalled(act, customTabPackage) &&
            (customTabPackage.equals(STABLE_PACKAGE, ignoreCase = true) ||
                    customTabPackage.equals(DEV_PACKAGE, ignoreCase = true) ||
                    customTabPackage.equals(BETA_PACKAGE, ignoreCase = true) ||
                    customTabPackage.equals(LOCAL_PACKAGE, ignoreCase = true))
        ) {
            try {
                val packageInfo = act.packageManager.getPackageInfo(customTabPackage, 0)
                return packageInfo.versionName.split(".")[0].toInt()
            } catch (e: Exception) {
                return -1
            }
        }
        return -1
    }

    /**
     * To be used as a fallback to open the Uri when Custom Tabs is not available.
     */
    fun interface CustomTabsFallback {
        /**
         * @param activity The Activity that wants to open the Uri.
         * @param uri      The uri to be opened by the fallback.
         */
        fun openUri(activity: Activity, uri: Uri)
    }

    companion object {
        private const val ACTION_CUSTOM_TABS_CONNECTION = "android.support.customtabs.action.CustomTabsService"
        private const val EXTRA_CUSTOM_TABS_KEEP_ALIVE = "android.support.customtabs.extra.KEEP_ALIVE"
        private const val LOCAL_PACKAGE = "com.google.android.apps.chrome"
        private const val STABLE_PACKAGE = "com.android.chrome"
        private const val BETA_PACKAGE = "com.chrome.beta"
        private const val DEV_PACKAGE = "com.chrome.dev"

        /**
         * Fallback in case there was en error launching custom tabs
         */
        private val CUSTOM_TABS_FALLBACK = CustomTabsFallback { activity, uri ->
            val string = activity.getString(R.string.fallback_msg)
            Toast.makeText(activity, string, Toast.LENGTH_SHORT).show()
            try {
                val intent = Intent(activity, WebViewActivity::class.java)
                intent.data = uri
                activity.startActivity(intent)
            } catch (e: ActivityNotFoundException) {
                Toast.makeText(activity, activity.getString(R.string.unxp_err), Toast.LENGTH_SHORT).show()
            }
        }

        /**
         * Helper method to get the correct PendingIntent flags for Android 12+
         * Android 12 (API 31) requires FLAG_IMMUTABLE or FLAG_MUTABLE
         */
        private fun getPendingIntentFlags(): Int {
            return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                FLAG_UPDATE_CURRENT or FLAG_IMMUTABLE
            } else {
                FLAG_UPDATE_CURRENT
            }
        }

        /**
         * Attempts to find the custom the best custom tab package to use.
         *
         * @return A package that supports custom tab, null if not present
         */
        private fun getCustomTabPackage(context: Context): String? {
            val userPackage = Preferences.get(context).customTabPackage()
            if (!userPackage.isNullOrEmpty()) {
                return userPackage
            }
            if (isPackageSupportCustomTabs(context, STABLE_PACKAGE))
                return STABLE_PACKAGE
            if (isPackageSupportCustomTabs(context, LOCAL_PACKAGE))
                return LOCAL_PACKAGE

            val supportingPackages = getCustomTabSupportingPackages(context)
            return if (supportingPackages.isNotEmpty()) {
                supportingPackages[0]
            } else {
                null
            }
        }

        /**
         * Returns all valid custom tab supporting browser packages on the system. Does not respect if
         * the package is default or not.
         *
         * @param context context to work with
         * @return list of packages supporting CCT
         */
        @TargetApi(Build.VERSION_CODES.M)
        fun getCustomTabSupportingPackages(context: Context): List<String> {
            val pm = context.applicationContext.packageManager
            val activityIntent = Intent(Intent.ACTION_VIEW, Uri.parse("http://www.example.com"))
            // Get all apps that can handle VIEW intents.
            val resolvedActivityList = pm.queryIntentActivities(activityIntent, PackageManager.MATCH_ALL)
            val packagesSupportingCustomTabs = ArrayList<String>()
            for (info in resolvedActivityList) {
                if (isPackageSupportCustomTabs(context, info.activityInfo.packageName)) {
                    packagesSupportingCustomTabs.add(info.activityInfo.packageName)
                }
            }
            return packagesSupportingCustomTabs
        }

        /**
         * Determines if the provided package name is a valid custom tab provider or not.
         *
         * @param context     Context to work with
         * @param packageName Package name of the app
         * @return true if a provider, false otherwise
         */
        fun isPackageSupportCustomTabs(context: Context, packageName: String?): Boolean {
            if (packageName == null) {
                return false
            }
            val pm = context.applicationContext.packageManager
            val serviceIntent = Intent()
            serviceIntent.action = ACTION_CUSTOM_TABS_CONNECTION
            serviceIntent.setPackage(packageName)
            return pm.resolveService(serviceIntent, 0) != null
        }
    }
}
